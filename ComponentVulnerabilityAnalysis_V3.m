%% Component vulnerability analysis
% 计算构件易损性分析
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 文件名：ComponentVulnerabilityAnalysis_V2
%V2表示该版本为2
%编写时间：2021.8.4
%作者：朱汉波
%单位：东南大学
%部门：土木工程学院
%邮箱地址：zhubobo610113@163.com
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 改进
% 增加自动筛选程序
%% 函数
% function ComponentVulnerabilityAnalysisOfPiers_V2
%% 当作主函数函数测试
%% example1
clc
clear
%% modify parameter 
FilePath='F:\matlab2017.8.8\2021.4.28_51dadaoqiao\51dadaoqiao_V22';%% V21为考虑结构随机性的计算结果、V22为不考虑结构随机性的计算结果
FileName='EDP_IMs.mat';
%% 函数过程;
%% 0 基本计算
EDP_IMs=load([FilePath,'\',FileName]);%
IMs_S=EDP_IMs.IMs.IMs_yDir;% or IMs_xDir
EDPs_S=EDP_IMs.EDPs;
% 1. x_Norm x y Names_C
Names_C=fieldnames(IMs_S);
Names_Str=string(Names_C);
% x_C=cellfun(@(x){getfield(IMs_S,x,'SampleNorm')},Names_C);
% x_Norm=cell2mat(x_C');
x_C=cellfun(@(x){getfield(IMs_S,x,'Sample')},Names_C);
x=cell2mat(x_C');
x_Norm=x./repmat(mean(x,1),size(x,1),1);
% 1.2 y
y=EDP_IMs.EDP;  
% 2.聚类分组数（即：选择的参数数量）
ParaNum=3;
% 3.概率地震需求分析
ComponentName='桥墩柱';
NameYLabel='修正的Park_Ang指标';
NameYLabel1='D';
% SYMBOLIC MACHINE LEARNING PLATFORM FOR MATLAB  https://sites.google.com/site/gptips4matlab/home
%Func_F=@(PGD,PredfyK,SMA)1.10141733623292 + 0.40876226023685*PGD - 0.106188116048452*PredfyK.*SMA - 0.104584732741426*PGD.^2.*exp((0.20407139553143.*PGD).^(-595));%不考虑结构随机性的顺桥向
Func_F=@(PGD,I_Ca,SMA)20.9999858031508*I_Ca.*exp(-59.02379726819.*I_Ca.^2) - 0.319743916107698.*log(8.04539217403582e-7.^(4.48271187072727 + PGD) - PGD);%不考虑结构随机性的横桥向

% 4.分位点
N=1;%极限状态倍数作为EDP取值上限
Ceo_Sta=1;%标准化系数（构件高度）
y_StaLimV=[0.08,0.3,0.68,1];%标准化后构件地震需求参数分位点
y_StaLimLV=log([0.08,0.3,0.68,1]);%标准化后构件地震需求参数对数分位点
Name_LimV={'轻微损伤状态','中等损伤状态','严重损伤状态','完全破坏状态'};
%% 1 因变量和自变量
%已知：因变量IMs矩阵、自变量EDPs向量；计算x_T
x_C1=mat2cell(x_Norm,ones(1,size(x_Norm,1)),ones(1,size(x_Norm,2)));
xNorm_T=cell2table(x_C1,'VariableNames',Names_C);
x_C1=mat2cell(x,ones(1,size(x,1)),ones(1,size(x,2)));
x_T=cell2table(x_C1,'VariableNames',Names_C);
%% 2 岭回归筛除无关项
%% 2.1 Lasso法
% AbsTol:为收敛条件
% Alpha：1表示lasso；0表示岭回归，
% B0:初始向量的相关系数，按照不相关计算
% CV:为 交叉验证的设置。用于估计最佳的λ的值。 默认为“resubstitution”,这个我没有研究，而是使用了较为广泛的 K折交叉验证，一般 赋值 k =5或10，就是 5折交叉验证或10折交叉验证
% DFmax：返回拟合式中 非零系数的数量。
c=cvpartition(length(y),'HoldOut',1/5);
%% F_LassoL  (0~0.05)
k_L=linspace(0,0.05,101);
[B_L,FitInfo_L]=lasso(x,y,'Alpha',1,'CV',c,'Lambda',k_L,'MCReps',10,'PredictorNames',Names_C); 
B_LMaxV=max(abs(B_L),[],2);
B_LBasic=B_L./B_LMaxV;
% axis([-inf,inf,-2e4,2e4])
% figure
% F_LassoL=plot(k_L,B_LBasic,'LineWidth',2);
%% F_LassoLR  (0~0.2)
k_LR=linspace(0,1,101);
[B_LR,FitInfo_LR]=lasso(x,y,'Alpha',1,'CV',c,'Lambda',k_LR,'MCReps',10,'PredictorNames',Names_C); 
B_LRMaxV=max(abs(B_LR),[],2);
B_LRBasic=B_LR./B_LRMaxV;
% figure
% F_LassoLR=plot(k_LR,B_LRBasic,'LineWidth',2);
%% F_LassoR   (0~1)
k_R=linspace(0,1,101);
[B_R,FitInfo_R]=lasso(x,y,'Alpha',1,'CV',c,'Lambda',k_R,'MCReps',10,'PredictorNames',Names_C); 
B_RMaxV=max(abs(B_R),[],2);
B_RBasic=B_R./B_RMaxV;
% figure
% F_LassoR=plot(k_R,B_RBasic,'LineWidth',2);
%% 2.5 筛除后剩余项
%% 观察法
% {'PGA';'PGV';'PGD';'SMA';'SMV';'Ecum';'t_5_95';'t_5_75';'arias';'I_a';'P_d';'a_sq';'v_sq';'I_D';'I_F';'v_CA';'a_RMS';'v_RMS';'d_RMS';'I_c';'I_Cd';'I_Cv';'I_Ca';'PredPSa';'PredPSv';'PredSa';'PredSv';'PredSd';'SIv';'SIa';'SaGMAS_C';'SaGMAS_L';'PSaGMAS_T';'PSaGMAS_A';'PredCDPSa';'PredCDPSv';'PredCDSd';'PredCDSv';'PredCDSa';'PredfyK';'PredmuK';'Tm';'Fm';'N_cy'}
% Names_Dele={'EDA1';'t_5_75';'P_d';'I_D';'I_c';'I_Cd';'SIv';'SIa';'SaGMAS_C';'PredCDPSv';'PredCDSd';'PredCDSa';'PredmuK'};%支座横桥向
% Names_Dele={'PGA';'EDA1';'t_5_75';'P_d';'I_D';'d_RMS';'I_c';'I_Cv';'I_Ca';'PredPSa';'SIv';'SIa';'SaGMAS_C';'SaGMAS_L';'PSaGMAS_T';'PredCDPSv';'PredCDSd';'PredCDSa';'PredmuK';'Fm'};%支座横桥向
% Names_Dele={'SMV';'EDA1';'Ecum';'t_5_95';'t_5_75';'P_d';'v_sq';'v_CA';'a_RMS';'d_RMS';'PredSa';'PredSd';'SIv';'SaGMAS_C';'SaGMAS_L';'PSaGMAS_T';'PSaGMAS_A';'PredmuK';'Tm';'Fm';'N_cy'};%上部结构横桥向
% Names_Dele={'SMV';'EDA1';'Ecum';'t_5_75';'I_a';'P_d';'v_sq';'I_F';'a_RMS';'v_RMS';'d_RMS';'PredSa';'PredSd';'SIa';'SIv';'SaGMAS_C';'SaGMAS_L';'PSaGMAS_T';'PSaGMAS_A';'PredCDPSv';'PredmuK';'Tm';'Fm';'N_cy'};%上部结构纵桥向
% Names_Dele={'SMA';'Ecum';'t_5_75';'arias';'I_a';'P_d';'v_sq';'I_D';'a_RMS';'v_RMS';'PredSa';'PredPSa';'PredCDPSa';'PredCDSa';'PredmuK';'Tm';'Fm';'N_cy'};%桥梁纵桥向墩柱
% Names_Dele={'SMA';'Ecum';'P_d';'v_sq';'v_CA';'a_RMS';'v_RMS';'PredPSa';'PredPSv';'PredSa';'PredCDPSa';'N_cy'};%桥梁横桥向墩柱
% Names_Dele={'SMV';'Ecum';'P_d';'v_sq';'v_CA';'PredSa';'SIa';'PSaGMAS_T';'PredCDPSa';'PredCDSa';'Fm';'N_cy'};%不考虑结构随机性的桥梁墩柱
% Names_Dele={'PGA';'PGV';'Ecum';'t_5_75';'P_d';'v_sq';'v_CA';'v_RMS';'PredSd';'SIa';'SaGMAS_C';'SaGMAS_L';'PSaGMAS_T';'PSaGMAS_A';'PredCDPSa';'PredCDSa';'PredmuK';'Fm';'N_cy'};%不考虑结构随机性的桥梁墩柱
% Names_Dele={'PGA';'PGV';'Ecum';'P_d';'v_sq';'v_CA';'v_RMS';'I_Cv';'PredSd';'SIa';'SaGMAS_C';'SaGMAS_L';'PSaGMAS_T';'PredCDPSa';'PredCDSa';'PredmuK';'Fm';'N_cy'};%不考虑结构随机性的桥梁墩柱顺桥向
% Names_Dele={'Ecum';'P_d';'a_sq';'v_sq';'I_D';'v_CA';'v_RMS';'I_c';'I_Cv';'PredPSa';'PredSd';'SIa';'PredCDPSa';'PredCDSa';'PredmuK';'Fm';'N_cy'};%不考虑结构随机性的桥梁墩柱顺桥向
%% 程序判别法
NamesDele_S=string([]);
NamesDele_S=SelectIMsWithSmallRidgeRegressionCorrelation(NamesDele_S,Names_Str,B_LBasic);
NamesDele_S=SelectIMsWithSmallRidgeRegressionCorrelation(NamesDele_S,Names_Str,B_LRBasic);
NamesDele_S=SelectIMsWithSmallRidgeRegressionCorrelation(NamesDele_S,Names_Str,B_RBasic);
NamesDele_C1=mat2cell(NamesDele_S,ones(length(NamesDele_S),1));
Names_Dele=cellfun(@(x)char(x),NamesDele_C1,'UniformOutput',false);
%% 中间变量
xNorm_S=table2struct(xNorm_T);
x_S=table2struct(x_T);
xNormL_S=rmfield(xNorm_S,Names_Dele);%经过Lasso筛选后剩余参数
xL_S=rmfield(x_S,Names_Dele);
%NamesL_C=fieldnames(xNormL_S);
NamesL_C=fieldnames(xL_S);
NamesL_Str=string(NamesL_C);
xNormL_T=struct2table(xNormL_S);
xL_T=struct2table(xL_S);
xNormL_C=struct2cell(xNormL_S);
xL_C=struct2cell(xL_S);
xNormL=cell2mat(xNormL_C');
xL=cell2mat(xL_C');
%% 3 K均值聚类（K-means）和 K中心点聚类（K-medoids）方法
%当样本数>10000使用kmedoid方法聚类、当样本数<=10000使用kmean方法聚类
%% 3.1 聚类计算
%% kmean kmedoids
% sampleNum=size(xL,1);
% if sampleNum<=10000
%     idx_k=kmeans(xL',ParaNum,'Distance','correlation','MaxIter',10000);
% else
%     idx_k=kmedoids(xL',ParaNum,'Distance','correlation','MaxIter',10000);
% end
%% GBKmeans
% Output=GBKmeans(xL', ParaNum);
% idx_k=(Output.Idx)';
%% LGC
% [idx_k,c1,a]=LGC(xL',5,ParaNum,0.4);
%% DBSCAN
% idx_k=DBSCAN(xL',0.5,10);
%% CLA
clear idx_k
neighborNums=length(NamesL_Str);
while exist('idx_k')==0
    try
        [idx_k,~] = CLA(xL',neighborNums);
    catch
        neighborNums=neighborNums-1;
    end
end
while max(idx_k)<3
    neighborNums=neighborNums-1;
    [idx_k,~] = CLA(xL',neighborNums);
end
idx_k=double(idx_k);
ParaNum1=max(idx_k);
%% 3.2 分类保存数据
Cluster_C=cell(ParaNum1,1);
NamesL_Str=string(NamesL_C);
FinalParas_Str=[];
for i=1:ParaNum1
    [Seri_Names,~]=find(idx_k==i);
    NamesInGroup_Str=NamesL_Str(Seri_Names);
    Cluster_C{i,1}=NamesInGroup_Str;
%% 4 相关性算法
%用过滤法（Filter）进行相关性分析终选
%     (1.1)皮尔森相关系数（Pearson）
%     (1.2)斯皮尔曼等级相关系数（Spearman）
%     (1.3)肯德尔和谐系数（Kendall）
%     (1.4)距离相关系数（Distance Correlation）
%     (1.5)最大信息系数（MIC）
    x_InGroup=xL(:,Seri_Names);
    %% 4.1 相关性算法
    %% 4.1.1 皮尔森相关系数（Pearson）
    %RHO_Pearson越接近-1或1，相关性高，接近0，相关性低；PVAL_Pearson越小，相关性越高
    [RHO_Pearson,~]=corr(x_InGroup,y,'type','Pearson');
    [~,Rank1]=sort(abs(RHO_Pearson));
    [~,Rank2]=sort(Rank1);
    Rank_Pearson=(length(RHO_Pearson)+1)-Rank2;
    %% 4.1.2 斯皮尔曼等级相关系数（Spearman）
    %RHO_Spearman越接近-1或1，相关性高，接近0，相关性低；PVAL_Spearman越小，相关性越高
    [RHO_Spearman,~]=corr(x_InGroup,y,'type','Spearman');
    [~,Rank1]=sort(abs(RHO_Spearman));
    [~,Rank2]=sort(Rank1);
    Rank_Spearman=(length(RHO_Spearman)+1)-Rank2;
    %% 4.1.3 肯德尔和谐系数（Kendall）
    %RHO_Kendall越接近-1或1，相关性高，接近0，相关性低；PVAL_Kendall越小，相关性越高
    [RHO_Kendall,~]=corr(x_InGroup,y,'type','Kendall');
    [~,Rank1]=sort(abs(RHO_Kendall));
    [~,Rank2]=sort(Rank1);
    Rank_Kendall=(length(RHO_Kendall)+1)-Rank2;
    %% 4.1.4 距离相关系数 (Distance Correlation)
    % dcor越大，相关性越高
    RHO_DC=arrayfun(@(z)distcorr(x_InGroup(:,z),y),1:size(x_InGroup,2))';
    [~,Rank1]=sort(RHO_DC);
    [~,Rank2]=sort(Rank1);
    Rank_DC=(length(RHO_DC)+1)-Rank2;
    %% 4.1.5 最大信息系数（MIC）
    %mic越大，相关性越高
    mic=arrayfun(@(z)getfield(mine(x_InGroup(:,z)',y'),'mic'),1:size(x_InGroup,2))';
    [~,Rank1]=sort(mic);
    [~,Rank2]=sort(Rank1);
    Rank_MIC=(length(mic)+1)-Rank2;
    %% 4.2 综合打分排序
    %CorRank_M=[Rank_Pearson,Rank_Spearman,Rank_Kendall,Rank_DC,Rank_MIC];
    CorRank_M=[Rank_Kendall*1,Rank_DC*2,Rank_MIC*3];
    AllRank_V=sum(CorRank_M,2);
    [~,Seri_InGroup]=min(AllRank_V);
    Name_InGroup=NamesInGroup_Str(Seri_InGroup);
    FinalParas_Str=[FinalParas_Str;Name_InGroup];
end
Seri_FinalParas=arrayfun(@(x)find(strcmp(NamesL_Str,FinalParas_Str(x,1))),1:ParaNum1);
%xNormF_S=getfield(xNormL_S,FinalParas_Str');%使用过滤法（Filter）得到缩减地震强度参数后的矩阵（n*ParaNum）
%xFP_Norm=xNormL(:,Seri_FinalParas);
%% 给聚类相关性选择的ParaNum组指标按照MIC排序
xFP=xL(:,Seri_FinalParas);
mic=arrayfun(@(z)getfield(mine(xFP(:,z)',y'),'mic'),1:size(xFP,2))';
[~,Rank1]=sort(mic);
[~,Rank2]=sort(Rank1);
Rank_MIC=(length(mic)+1)-Rank2;
xFP1=[];
FinalParas_Str1=[];
for i=1:ParaNum
    seri=find(Rank_MIC==i);
    xFP1=[xFP1,xFP(:,seri)];
    FinalParas_Str1=[FinalParas_Str1;FinalParas_Str(seri)];
end
xFP=xFP1;
FinalParas_Str=FinalParas_Str1;
%% 5 去除反应超限的N倍的状况
y_Sta=y/Ceo_Sta;
y_StaULim=y_StaLimV(end);
Seri_Remain=find(y_Sta<y_StaULim*N);
y_StaRe=y_Sta(Seri_Remain);
%xFP_NormRe=xFP_Norm(Seri_Remain,:);
xFP_Re=xFP(Seri_Remain,:);
y_StaReL=log(y_StaRe);%保留的地震需求响应值
%xFP_NormReL=log(xFP_NormRe);
xFP_ReL=log(xFP_Re);%选出的地震强度指标对数值
%% 5 符号回归（Symbolic Regression）
% 使用Symbolic Regression https://www.gptips.org/ 下的GPTIPS(SYMBOLIC MACHINE LEARNING PLATFORM FOR MATLAB)
y_CalL=Func_F(xFP_ReL(:,1),xFP_ReL(:,2),xFP_ReL(:,3));
% y_CalL=Func_F(xFP_ReL(:,1));
figure;
%设置坐标线宽，加边框
axes('linewidth',1,'box','off','FontSize',16);
%设置坐标值label
xlabel({'多元强度对数复合指标','In(IMs)'},'FontSize',16,'FontWeight','normal');%{'位移峰值','In(d_P_G)'}
ylabel({'对数修正的park-Ang损伤指标','In(D)'},'FontSize',16,'FontWeight','normal');
hold on
Line1=scatter(y_CalL,y_StaReL,20,'filled');
XIni_Func=min(y_CalL);
XEnd_Func=max(y_CalL);
axis([XIni_Func +inf XIni_Func +inf])
%使用Eurqua的拟合函数
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Func_FC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
x_Fit=XIni_Func:0.01:XEnd_Func;
y_Fit=XIni_Func:0.01:XEnd_Func;
Line2=plot(x_Fit,y_Fit,'LineWidth',2,'Color','r');
hold off
mkdir([FilePath,'\PerformanceAssessmentResults\Figure']);
saveas(gcf,[FilePath,'\PerformanceAssessmentResults\Figure\横桥向',ComponentName,NameYLabel,'拟合函数.emf']);
%% 6 易损性函数
%% 6.1 对数距离权重参数Omega
y_StaReLmin1=min(y_StaReL);
y_StaReLmax1=max(y_StaReL);
N_Dk=length(y_StaReL);%样本数量
Para_C=regexp(char(Func_F),'[0-9]+.?[0-9]*','match');
n_Dk=length(Para_C);%拟合公式中的参数数量
figure
axes('linewidth',1,'box','on','FontSize',20,'Fontname','Times New Roman')
LegHandles = []; LegText = {};
%设置坐标值label
xlabel({'多元强度对数复合指标','In(IMs)'},'FontSize',16,'FontWeight','normal','Fontname','Times New Roman');%{'位移峰值','In(d_P_G)'}
ylabel({'损伤状态Ds超越概率'},'FontSize',16,'FontWeight','normal','Fontname','Times New Roman');
box off
BetaDk_V=[];
y_LimV=[y_StaReLmin1,y_StaLimLV,y_StaReLmax1];
for j=1:length(y_StaLimLV)
    y_StaReLmin=y_StaReLmin1;%y_LimV(j);y_StaReLmin1
    y_StaReLmax=y_StaReLmax1;%y_LimV(j+2);y_StaReLmax1
    D_k=y_StaLimLV(j);
    Omega_V=[];
    for i=1:length(y_StaReL)
        y_i=y_StaReL(i);
        Omega=1-((D_k-y_i)/(max(D_k-y_StaReLmin,y_StaReLmax-D_k)))^2;%对数距离
        Omega_V=[Omega_V;Omega];
    end
    Seri_yi1=find(y_StaReL<=y_StaReLmax&y_StaReL>=y_StaReLmin);
    %% 6.2对数标准差 
    mu_Dk=y_StaLimLV(j);
    Beta_Dk=sqrt(sum(Omega_V(Seri_yi1).*(y_StaReL(Seri_yi1)-y_CalL(Seri_yi1)).^2)/sum(Omega_V(Seri_yi1).*(1-n_Dk/length(y_StaReL(Seri_yi1)))));
    %正态分布累积函数
    pd_Dk = makedist('Normal','mu',mu_Dk,'sigma',Beta_Dk);%损伤状态Dk的分布函数
    x_pdfDk = linspace(-6,2,100);
    x_cdfDk = x_pdfDk;
    y_pdfDk = pdf('Normal',x_pdfDk,mu_Dk,Beta_Dk);
    y_cdfDk = cdf('Normal',x_cdfDk,mu_Dk,Beta_Dk);
    BetaDk_V=[BetaDk_V;Beta_Dk];
    hold on
    hLine=plot(x_cdfDk,y_cdfDk,'LineWidth',2);
    LegHandles(end+1) = hLine;
    LegText{end+1} = Name_LimV{1, j}  ;
end
hLegend = legend(LegHandles,LegText,'Orientation', 'vertical', 'FontSize', 12, 'Location', 'northwest');
set(hLegend,'Interpreter','none');
hold off
mkdir([FilePath,'\PerformanceAssessmentResults\Figure']);
saveas(gcf,[FilePath,'\PerformanceAssessmentResults\Figure\横桥向',ComponentName,NameYLabel,'易损性曲线1.emf']);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 函数概况
%通过编程方式筛选关联性较小参数
%% 方法声明：
% 分段筛选
%% 调用函数声明：
% matlab自带函数
% union:
%% 待求量声明：
% NamesDele_S：删除的字符串向量，string
%% 带入参数声明：
% NamesDele_S：初始删除的字符串向量，string
% 

%% 函数
function NamesDele_S=SelectIMsWithSmallRidgeRegressionCorrelation(NamesDele_S,Names_Str,B_Basic)
%% 函数过程
NamesDele_S1=NamesDele_S;
NamesDele_S2=string([]);
% 用单调判断
for i=1:length(Names_Str)
    B_V=B_Basic(i,:);
    B_VIni=B_V(1);
    if B_VIni==-1 || B_VIni==1
        %用首次出现0的位置将向量分为两段判断
        Posi_B=find(B_V==0);
        if ~isempty(Posi_B)% 出现0点
            Posi_B0=Posi_B(1);
            B_1V=B_V(1:Posi_B0-1);
            B_2V=B_V(Posi_B0:end);
            % 判断前半段是否单调或贯穿正负值
            if length(B_1V)>1
                B_1IncrV=B_1V(2:end)-B_1V(1:end-1);
                if range(sign(B_1IncrV))~=0||range(sign(B_1V))~=0
                    NamesDele_S2=[NamesDele_S2;Names_Str(i,1)];%将出现0之前向量不单调或贯穿正负，作为删除项
                end
            end
            % 判断后半段是否有非0要素
            if range(sign(B_2V))~=0
                NamesDele_S2=[NamesDele_S2;Names_Str(i,1)];% 将出现0之后的向量有非零点
            end
        else %未出现0点
            B_IncrV=B_V(2:end)-B_V(1:end-1);
            if range(sign(B_IncrV))~=0||range(sign(B_V))~=0
                NamesDele_S2=[NamesDele_S2;Names_Str(i,1)];%
            end
        end
    else
        NamesDele_S2=[NamesDele_S2;Names_Str(i,1)];%岭回归向量若起始值不为1或-1，作为删除项
    end
end
NamesDele_S=union(NamesDele_S1,NamesDele_S2);
end

% % 用单调判断
% Names_Dele=cell(0,1);
% for i=1:length(Names_Str)
%     B_V=B_LBasic(i,:);
%     B_VIni=B_V(1);
%     if B_VIni==-1 || B_VIni==1
%         %用首次出现0的位置将向量分为两段判断
%         Posi_B=find(B_V==0);
%         if ~isempty(Posi_B)% 出现0点
%             Posi_B0=Posi_B(1);
%             B_1V=B_V(1:Posi_B0-1);
%             B_2V=B_V(Posi_B0:end);
%             % 判断前半段是否单调或贯穿正负值
%             if length(B_1V)>1
%                 B_1IncrV=B_1V(2:end)-B_1V(1:end-1);
%                 if range(sign(B_1IncrV))~=0||range(sign(B_1V))~=0
%                     Names_Dele=[Names_Dele;mat2cell(char(Names_Str(i,1)),1)];%将出现0之前向量不单调或贯穿正负，作为删除项
%                 end
%             end
%             % 判断后半段是否有非0要素
%             if range(sign(B_2V))~=0
%                 Names_Dele=[Names_Dele;mat2cell(char(Names_Str(i,1)),1)];% 将出现0之后的向量有非零点
%             end
%         else %未出现0点
%             B_IncrV=B_V(2:end)-B_V(1:end-1);
%             if range(sign(B_IncrV))~=0||range(sign(B_V))~=0
%                 Names_Dele=[Names_Dele;mat2cell(char(Names_Str(i,1)),1)];%
%             end
%         end
%     else
%         Names_Dele=[Names_Dele;mat2cell(char(Names_Str(i,1)),1)];%岭回归向量若起始值不为1或-1，作为删除项
%     end
% end

